## 快速排序

### 手写快排。 快排其实是分治思想的一种，通过找一个基准点，使得该基准点左边的数字都小于等于该基准，基准点右边的数字都大于等于该基准，然后将左右两部分再进行排序，使得总体有序。实现方法通常使用头尾指针。
```java
	public void quickSort(int[] nums) {
		quickSort(nums, 0, nums.length - 1);
	}

	public void quickSort(int[] arr, int low, int high) {
		int i, j, temp, t;
		if (low > high)
			return;
		i = low;
		j = high;
		
		temp = arr[low];

		while (i < j) {
			while (temp <= arr[j] && i < j) {
				j--;
			}
			while (temp >= arr[i] && i < j) {
				i++;
			}
			if (i < j) {
				t = arr[j];
				arr[j] = arr[i];
				arr[i] = t;
			}
		}

		arr[low] = arr[i];
		arr[i] = temp;

		quickSort(arr, low, j - 1);
		quickSort(arr, j + 1, high);
	}
  ```
   数据结构 heap

题目：

讲一讲 heap 是什么？手写一个 heap

思路：

heap 即堆，根据性质可以分为大根堆和小根堆，存储形式是一棵完全二叉树，因此使用数组来保存。如果是大根堆，那么父节点大于等于子节点，根节点是最大的。如果是小根堆，那么父节点小于等于子节点，根节点是最小的。 手写堆就不手写了，直接附上源码
```java
import java.util.Arrays;
import java.util.Comparator;

import javax.security.auth.x500.X500Principal;

public class Heap<E> {

	Object[] queue;
	
	private int size;
	
	private static final int DEFAULT_SIZE = 16;
	
	private Comparator<? extends E> comparator;
	
	public Heap() {
		this(DEFAULT_SIZE, null);
	}
	
	public Heap(Comparator<? extends E> comparator) {
		this(DEFAULT_SIZE, comparator);
	}
	
	public Heap(int initialCapacity, Comparator<? extends E> comparator) {
		this.queue = new Object[initialCapacity];
	}
	
	public void grow(int size) {
//		当容量不足时，增加25%
		int oldCapacity = queue.length;
		int newCapacity = oldCapacity + (oldCapacity<=64?oldCapacity + 2:oldCapacity>>2);
		queue = Arrays.copyOf(queue, newCapacity);
	}
	
//	取出元素
	public E poll() {
		if (size == 0)
            return null;
		int s = --size;
        E result = (E) queue[0];
        E x = (E) queue[s];
        queue[s] = null;
        if (s != 0)
        	shiftDown(0, x);
        return result;
	}
	
//	插入元素
	public boolean add(E e) {
		if(e == null)
			throw new NullPointerException();
		int i = size;
		if(i >= queue.length) {
			grow(i + 1);
		}
		shiftUp(i, e);
		size ++;
		return true;
	}
	
	private void shiftDown(int k, E x) {
		Comparable<? super E> key = (Comparable<? super E>)x;
        int half = size >>> 1;
        while (k < half) {
            int child = (k << 1) + 1; 
            Object c = queue[child];
            int right = child + 1;
            if (right < size &&
                ((Comparable<? super E>) c).compareTo((E) queue[right]) > 0)
                c = queue[child = right];
            if (key.compareTo((E) c) <= 0)
                break;
            queue[k] = c;
            k = child;
        }
        queue[k] = key;
	}
	
	private void shiftUp(int k, E e) {
		Comparable<? super E> key = (Comparable<? super E>) e;
		while(k > 0) {
			int parent = (k -1) >>> 1; 
			Object t = queue[parent];
			if(key.compareTo((E) t) >= 0) {
				break;
			}
			queue[k] = t;
			k = parent;
		}
		queue[k] = key;
	}
}
```
